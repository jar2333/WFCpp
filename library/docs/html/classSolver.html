<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WFCPP: Solver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">WFCPP<span id="projectnumber">&#160;0.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSolver-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Solver Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classSolver.html" title="The Solver class.">Solver</a> class.  
 <a href="classSolver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Solver_8h_source.html">Solver.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a624d11307b449d2e13dee24ec5170eed"><td class="memItemLeft" align="right" valign="top">typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a></td></tr>
<tr class="separator:a624d11307b449d2e13dee24ec5170eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9023dccd73fc12ad487d1f01e1a70082"><td class="memItemLeft" align="right" valign="top"><a id="a9023dccd73fc12ad487d1f01e1a70082" name="a9023dccd73fc12ad487d1f01e1a70082"></a>
typedef std::function&lt; std::vector&lt; <a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a> &gt;::const_iterator(const std::vector&lt; <a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a> &gt; &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CollapseBehavior</b></td></tr>
<tr class="separator:a9023dccd73fc12ad487d1f01e1a70082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd804104330d7de1d024957ef59a79b"><td class="memItemLeft" align="right" valign="top"><a id="a4bd804104330d7de1d024957ef59a79b" name="a4bd804104330d7de1d024957ef59a79b"></a>
typedef std::function&lt; void(const <a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a> &amp;, <a class="el" href="structPosition.html">Position</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CollapseCallback</b></td></tr>
<tr class="separator:a4bd804104330d7de1d024957ef59a79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017f6f4aec8b3eec43ea3130fe702286"><td class="memItemLeft" align="right" valign="top"><a id="a017f6f4aec8b3eec43ea3130fe702286" name="a017f6f4aec8b3eec43ea3130fe702286"></a>
typedef std::function&lt; void(const std::vector&lt; <a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a> &gt; &amp;, <a class="el" href="structPosition.html">Position</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>PropagateCallback</b></td></tr>
<tr class="separator:a017f6f4aec8b3eec43ea3130fe702286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc55f3b23ccda7c353df7abfb678f150"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; CollapseCallback &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver.html#abc55f3b23ccda7c353df7abfb678f150">CollapseCallbackCookie</a></td></tr>
<tr class="separator:abc55f3b23ccda7c353df7abfb678f150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4c0aafb91c3db2531d97fe61d8afb7"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; PropagateCallback &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver.html#ace4c0aafb91c3db2531d97fe61d8afb7">PropagateCallbackCookie</a></td></tr>
<tr class="separator:ace4c0aafb91c3db2531d97fe61d8afb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab9943f77531798a2f6ce24b8281d71a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab9943f77531798a2f6ce24b8281d71a3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSolver.html#ab9943f77531798a2f6ce24b8281d71a3">Solver</a> (const std::vector&lt; T &gt; &amp;tiles, int seed=0)</td></tr>
<tr class="separator:ab9943f77531798a2f6ce24b8281d71a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b00bb931fe601491c521d6176cf77b5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7b00bb931fe601491c521d6176cf77b5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSolver.html#a7b00bb931fe601491c521d6176cf77b5">Solver</a> (const std::map&lt; <a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a>, T &gt; &amp;tiles, int seed=0)</td></tr>
<tr class="separator:a7b00bb931fe601491c521d6176cf77b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34198a1963bea018d0d7096dd36e3653"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver.html#a34198a1963bea018d0d7096dd36e3653">setSeed</a> (int seed)</td></tr>
<tr class="memdesc:a34198a1963bea018d0d7096dd36e3653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the seed for the random number generator.  <a href="classSolver.html#a34198a1963bea018d0d7096dd36e3653">More...</a><br /></td></tr>
<tr class="separator:a34198a1963bea018d0d7096dd36e3653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010ed819d6b21696564a5cc5cd5e2cbb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver.html#a010ed819d6b21696564a5cc5cd5e2cbb">getSeed</a> ()</td></tr>
<tr class="memdesc:a010ed819d6b21696564a5cc5cd5e2cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the seed for the random number generator.  <a href="classSolver.html#a010ed819d6b21696564a5cc5cd5e2cbb">More...</a><br /></td></tr>
<tr class="separator:a010ed819d6b21696564a5cc5cd5e2cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7406c53eecaf19b82b312791d8fcb0"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classGrid.html">Grid</a>&lt; <a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver.html#a7d7406c53eecaf19b82b312791d8fcb0">solve</a> (size_t N)</td></tr>
<tr class="separator:a7d7406c53eecaf19b82b312791d8fcb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889f4d7fb4caa5d53a5a54ef31592d13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver.html#a889f4d7fb4caa5d53a5a54ef31592d13">solve</a> (size_t N, <a class="el" href="classGrid.html">Grid</a>&lt; <a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a> &gt; &amp;grid)</td></tr>
<tr class="separator:a889f4d7fb4caa5d53a5a54ef31592d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e645865467108124343029fcd91504"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver.html#ae9e645865467108124343029fcd91504">addAdjacencyConstraint</a> (<a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a> t, Direction d, <a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a> neighbor)</td></tr>
<tr class="separator:ae9e645865467108124343029fcd91504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac103dc80c8f2e6b8f96d6890c7e0f1e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver.html#ac103dc80c8f2e6b8f96d6890c7e0f1e8">removeAdjacencyConstraint</a> (<a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a> t, Direction d, <a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a> neighbor)</td></tr>
<tr class="separator:ac103dc80c8f2e6b8f96d6890c7e0f1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac358763cee631e16e737f69172bfb354"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver.html#ac358763cee631e16e737f69172bfb354">addAdjacencyConstraint</a> (<a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a> t, Direction d, std::initializer_list&lt; <a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a> &gt; neighbors)</td></tr>
<tr class="separator:ac358763cee631e16e737f69172bfb354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8f8508887d24dfe0807f394dd98fcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver.html#a4c8f8508887d24dfe0807f394dd98fcf">removeAdjacencyConstraint</a> (<a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a> t, Direction d, std::initializer_list&lt; <a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a> &gt; neighbors)</td></tr>
<tr class="separator:a4c8f8508887d24dfe0807f394dd98fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30173570fd36893e302f9313fe030937"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver.html#a30173570fd36893e302f9313fe030937">setInitialConstraint</a> (<a class="el" href="structPosition.html">Position</a> p, <a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a> possibility)</td></tr>
<tr class="separator:a30173570fd36893e302f9313fe030937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db472c24ac7cdbba16b99226c53b82d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver.html#a8db472c24ac7cdbba16b99226c53b82d">setInitialConstraint</a> (<a class="el" href="structPosition.html">Position</a> p, std::initializer_list&lt; <a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a> &gt; possibilities)</td></tr>
<tr class="separator:a8db472c24ac7cdbba16b99226c53b82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21bdaffa17e0ef52e78ce64f2046b5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSolver.html#abc55f3b23ccda7c353df7abfb678f150">CollapseCallbackCookie</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver.html#aa21bdaffa17e0ef52e78ce64f2046b5b">registerOnCollapse</a> (CollapseCallback callback)</td></tr>
<tr class="separator:aa21bdaffa17e0ef52e78ce64f2046b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbca26de9fca6d061d0478dda6cc64f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver.html#acbca26de9fca6d061d0478dda6cc64f1">deregisterOnCollapse</a> (<a class="el" href="classSolver.html#abc55f3b23ccda7c353df7abfb678f150">CollapseCallbackCookie</a> cookie)</td></tr>
<tr class="separator:acbca26de9fca6d061d0478dda6cc64f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed54210e84c73fff7fb4f2be1e965457"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSolver.html#ace4c0aafb91c3db2531d97fe61d8afb7">PropagateCallbackCookie</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver.html#aed54210e84c73fff7fb4f2be1e965457">registerOnPropagate</a> (PropagateCallback callback)</td></tr>
<tr class="separator:aed54210e84c73fff7fb4f2be1e965457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fd0b667ebdf313e19616c33d3642c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver.html#a20fd0b667ebdf313e19616c33d3642c2">deregisterOnCollapse</a> (<a class="el" href="classSolver.html#ace4c0aafb91c3db2531d97fe61d8afb7">PropagateCallbackCookie</a> cookie)</td></tr>
<tr class="separator:a20fd0b667ebdf313e19616c33d3642c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b11638a34e8929a126607edbb125898"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver.html#a8b11638a34e8929a126607edbb125898">setCollapseBehaviour</a> (std::optional&lt; CollapseBehavior &gt; b)</td></tr>
<tr class="separator:a8b11638a34e8929a126607edbb125898"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >The <a class="el" href="classSolver.html" title="The Solver class.">Solver</a> class. </p>
<dl class="section author"><dt>Author</dt><dd>Jose A. Ramos</dd></dl>
<p>This class implements the Wave Function Collapse (WFC) algorithm. It provides an interface for calling the algorithm, for setting the solver constraints, changing some algorithm behavior, and registering for certain events. It utilizes keys to represent tiles, returning a 2D grid of keys.</p>
<p >At the moment, only 2 dimensional square grids are available to be solved by the algorithm. This limitation is not hard to overcome, and in fact this class can be generalized with minor changes to some key private methods and the Direction enum.</p>
<p >The algorithm consists of a grid, with each slot/square having a set of allowed tiles at any given time. In the WFC literature, this is called a "superposition", although we avoid that nomenclature. A grid square is said to be "collapsed" when only one tile is allowed in it. The grid itself is said to be "collapsed" when all of its squares are collapsed. This constitutes a "solved" grid. If a grid square ever has zero allowed tiles, that means the grid is in "contradiction". A solution cannot be found from a contradiction.</p>
<p >WFC works by iterating 3 steps until either the grid is solved or a leads to a contradiction:</p><ul>
<li>Find the non-collapsed grid square with the least number of allowed tiles (this is the "min entropy heuristic").</li>
<li>Collapse the grid square using some policy (usually uniform random sampling).</li>
<li>Propagate the results of the new collapsed grid square, removing tiles that are now disallowed by adjacency constraints.</li>
</ul>
<p >Beyond offering the solve method, this class provides an API to define <em>adjacency constraints</em> and <em>initial constraints</em>, which guide the final solution to the grid. Additionally, it provides an API for registering functions to be called on the information at a grid square whenever it either collapses or is affected by propagation. Finally, an API is provided for changing the way grid squares are collapsed.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classGrid.html">Grid</a> </dd>
<dd>
Direction </dd>
<dd>
<a class="el" href="structPosition.html">Position</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="abc55f3b23ccda7c353df7abfb678f150" name="abc55f3b23ccda7c353df7abfb678f150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc55f3b23ccda7c353df7abfb678f150">&#9670;&#160;</a></span>CollapseCallbackCookie</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;CollapseCallback&gt;::iterator <a class="el" href="classSolver.html#abc55f3b23ccda7c353df7abfb678f150">Solver::CollapseCallbackCookie</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The alias for the callback cookie type for collapse events </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSolver.html#aa21bdaffa17e0ef52e78ce64f2046b5b">registerOnCollapse(CollapseCallback callback)</a> </dd></dl>

</div>
</div>
<a id="ace4c0aafb91c3db2531d97fe61d8afb7" name="ace4c0aafb91c3db2531d97fe61d8afb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace4c0aafb91c3db2531d97fe61d8afb7">&#9670;&#160;</a></span>PropagateCallbackCookie</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;PropagateCallback&gt;::iterator <a class="el" href="classSolver.html#ace4c0aafb91c3db2531d97fe61d8afb7">Solver::PropagateCallbackCookie</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The alias for the callback cookie type for propagation events </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSolver.html#aed54210e84c73fff7fb4f2be1e965457">registerOnPropagate(PropagateCallback callback)</a> </dd></dl>

</div>
</div>
<a id="a624d11307b449d2e13dee24ec5170eed" name="a624d11307b449d2e13dee24ec5170eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624d11307b449d2e13dee24ec5170eed">&#9670;&#160;</a></span>TileKey</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t <a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">Solver::TileKey</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The alias for the key type used for tiles in the algorithm. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab9943f77531798a2f6ce24b8281d71a3" name="ab9943f77531798a2f6ce24b8281d71a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9943f77531798a2f6ce24b8281d71a3">&#9670;&#160;</a></span>Solver() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Solver::Solver </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>tiles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The tile keys are auto-generated from vector as the indeces. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tiles</td><td>A vector of tiles. </td></tr>
    <tr><td class="paramname">seed</td><td>The seed for the random number generator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b00bb931fe601491c521d6176cf77b5" name="a7b00bb931fe601491c521d6176cf77b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b00bb931fe601491c521d6176cf77b5">&#9670;&#160;</a></span>Solver() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Solver::Solver </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a>, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>tiles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Keeps track of tile keys from a given mapping of tile keys to tiles. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tiles</td><td>A map of tile keys to tiles. </td></tr>
    <tr><td class="paramname">seed</td><td>The seed for the random number generator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac358763cee631e16e737f69172bfb354" name="ac358763cee631e16e737f69172bfb354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac358763cee631e16e737f69172bfb354">&#9670;&#160;</a></span>addAdjacencyConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Solver::addAdjacencyConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Direction&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a> &gt;&#160;</td>
          <td class="paramname"><em>neighbors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A multi-argument version of <a class="el" href="classSolver.html#ae9e645865467108124343029fcd91504">Solver::addAdjacencyConstraint</a> Utilizes an initializer list, for use by programmers.</p>
<p >This method is idempotent.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSolver.html#ae9e645865467108124343029fcd91504">Solver::addAdjacencyConstraint(TileKey t, Direction d, TileKey neighbor)</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The tile key which will have a new possible neighbor </td></tr>
    <tr><td class="paramname">d</td><td>The direction in which the neighbor will be possible </td></tr>
    <tr><td class="paramname">neighbors</td><td>The tile keys which are allowed to be adjacent to t in direction d </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9e645865467108124343029fcd91504" name="ae9e645865467108124343029fcd91504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e645865467108124343029fcd91504">&#9670;&#160;</a></span>addAdjacencyConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Solver::addAdjacencyConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Direction&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a>&#160;</td>
          <td class="paramname"><em>neighbor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A method for adding an <em>adjacency constraint</em>. An adjacency constraint consists of a given tile, a direction, and a neighbor tile. The constraint specifies that the neighbor tile is allowed to be adjacent to the given tile in said direction. Inversely, if such a constraint does not exist, the neighbor tile is not allowed to be adjacent in that direction.</p>
<p >By default, if <b>no</b> constraint exists for a (tile, direction) pair, every tile is allowed to be adjacent to the given tile in that direction. This is why they are called <em>constraints</em>, since it constrains this default case by only allowing specific neighbors.</p>
<p >This method is idempotent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The tile key which will have a new possible neighbor </td></tr>
    <tr><td class="paramname">d</td><td>The direction in which the neighbor will be possible </td></tr>
    <tr><td class="paramname">neighbor</td><td>The tile key which is allowed to be adjacent to t in direction d </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbca26de9fca6d061d0478dda6cc64f1" name="acbca26de9fca6d061d0478dda6cc64f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbca26de9fca6d061d0478dda6cc64f1">&#9670;&#160;</a></span>deregisterOnCollapse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Solver::deregisterOnCollapse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSolver.html#abc55f3b23ccda7c353df7abfb678f150">Solver::CollapseCallbackCookie</a>&#160;</td>
          <td class="paramname"><em>cookie</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Deregisters a function that is called whenever a grid square collapses.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSolver.html#abc55f3b23ccda7c353df7abfb678f150">CollapseCallbackCookie</a> </dd>
<dd>
<a class="el" href="classSolver.html#aa21bdaffa17e0ef52e78ce64f2046b5b">registerOnCollapse(CollapseCallback callback)</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cookie</td><td>a cookie used to indentify and remove a callback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20fd0b667ebdf313e19616c33d3642c2" name="a20fd0b667ebdf313e19616c33d3642c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20fd0b667ebdf313e19616c33d3642c2">&#9670;&#160;</a></span>deregisterOnCollapse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Solver::deregisterOnCollapse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSolver.html#ace4c0aafb91c3db2531d97fe61d8afb7">Solver::PropagateCallbackCookie</a>&#160;</td>
          <td class="paramname"><em>cookie</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Deregisters a function that is called whenever a grid square is interacted with during constraint propagation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSolver.html#ace4c0aafb91c3db2531d97fe61d8afb7">PropagateCallbackCookie</a> </dd>
<dd>
<a class="el" href="classSolver.html#aed54210e84c73fff7fb4f2be1e965457">registerOnPropagate(PropagateCallback callback)</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cookie</td><td>a cookie used to indentify and remove a callback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a010ed819d6b21696564a5cc5cd5e2cbb" name="a010ed819d6b21696564a5cc5cd5e2cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a010ed819d6b21696564a5cc5cd5e2cbb">&#9670;&#160;</a></span>getSeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Solver::getSeed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the seed for the random number generator. </p>
<dl class="section return"><dt>Returns</dt><dd>the seed </dd></dl>

</div>
</div>
<a id="aa21bdaffa17e0ef52e78ce64f2046b5b" name="aa21bdaffa17e0ef52e78ce64f2046b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa21bdaffa17e0ef52e78ce64f2046b5b">&#9670;&#160;</a></span>registerOnCollapse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSolver.html#abc55f3b23ccda7c353df7abfb678f150">Solver::CollapseCallbackCookie</a> Solver::registerOnCollapse </td>
          <td>(</td>
          <td class="paramtype">Solver::CollapseCallback&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Registers a function to be called whenever a grid square collapses. The function argument is the tile key now occupying that grid square, and the position. Returns a cookie to allow deregistering the function later.</p>
<dl class="section see"><dt>See also</dt><dd>CollapseCallback </dd>
<dd>
<a class="el" href="classSolver.html#abc55f3b23ccda7c353df7abfb678f150">CollapseCallbackCookie</a> </dd>
<dd>
<a class="el" href="classSolver.html#acbca26de9fca6d061d0478dda6cc64f1">deregisterOnCollapse(CollapseCallbackCookie cookie)</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>a function to be called when a grid square collapses </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a cookie to be used for deregistering the callback </dd></dl>

</div>
</div>
<a id="aed54210e84c73fff7fb4f2be1e965457" name="aed54210e84c73fff7fb4f2be1e965457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed54210e84c73fff7fb4f2be1e965457">&#9670;&#160;</a></span>registerOnPropagate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSolver.html#ace4c0aafb91c3db2531d97fe61d8afb7">Solver::PropagateCallbackCookie</a> Solver::registerOnPropagate </td>
          <td>(</td>
          <td class="paramtype">Solver::PropagateCallback&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Registers a function to be called whenever a grid square collapses. The function argument is the tile key now occupying that grid square, and the position. Returns a cookie to allow deregistering the function later.</p>
<dl class="section see"><dt>See also</dt><dd>PropagateCallback </dd>
<dd>
<a class="el" href="classSolver.html#ace4c0aafb91c3db2531d97fe61d8afb7">PropagateCallbackCookie</a> </dd>
<dd>
<a class="el" href="classSolver.html#a20fd0b667ebdf313e19616c33d3642c2">deregisterOnCollapse(PropagateCallbackCookie cookie)</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>a function to be called when a grid square is interacted with during constraint propagation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a cookie to be used for deregistering the callback </dd></dl>

</div>
</div>
<a id="a4c8f8508887d24dfe0807f394dd98fcf" name="a4c8f8508887d24dfe0807f394dd98fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8f8508887d24dfe0807f394dd98fcf">&#9670;&#160;</a></span>removeAdjacencyConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Solver::removeAdjacencyConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Direction&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a> &gt;&#160;</td>
          <td class="paramname"><em>neighbors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A multi-argument version of <a class="el" href="classSolver.html#ae9e645865467108124343029fcd91504">Solver::addAdjacencyConstraint</a> Utilizes an initializer list, for use by programmers.</p>
<p >This method is idempotent.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSolver.html#ac103dc80c8f2e6b8f96d6890c7e0f1e8">Solver::removeAdjacencyConstraint(TileKey t, Direction d, TileKey neighbor)</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The tile key which will have a possible neighbor removed </td></tr>
    <tr><td class="paramname">d</td><td>The direction in which the neighbor will no longer be a possible </td></tr>
    <tr><td class="paramname">neighbors</td><td>The tile keys which are no longer allowed to be adjacent to t in direction d </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac103dc80c8f2e6b8f96d6890c7e0f1e8" name="ac103dc80c8f2e6b8f96d6890c7e0f1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac103dc80c8f2e6b8f96d6890c7e0f1e8">&#9670;&#160;</a></span>removeAdjacencyConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Solver::removeAdjacencyConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Direction&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a>&#160;</td>
          <td class="paramname"><em>neighbor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A method for removing an <em>adjacency constraint</em>.</p>
<p >This method is idempotent.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSolver.html#ae9e645865467108124343029fcd91504">Solver::addAdjacencyConstraint(TileKey t, Direction d, TileKey neighbor)</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The tile key which will have a possible neighbor removed </td></tr>
    <tr><td class="paramname">d</td><td>The direction in which the neighbor will no longer be a possible </td></tr>
    <tr><td class="paramname">neighbor</td><td>The tile key which is no longer allowed to be adjacent to t in direction d </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b11638a34e8929a126607edbb125898" name="a8b11638a34e8929a126607edbb125898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b11638a34e8929a126607edbb125898">&#9670;&#160;</a></span>setCollapseBehaviour()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Solver::setCollapseBehaviour </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; CollapseBehavior &gt;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Low level access function to change selection policy used in collapse. Can be set to a null value, in which case collapseRandom is used instead.</p>
<dl class="section see"><dt>See also</dt><dd>CollapseBehavior </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>a function which returns an iterator to a specific tile key in a grid square </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8db472c24ac7cdbba16b99226c53b82d" name="a8db472c24ac7cdbba16b99226c53b82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db472c24ac7cdbba16b99226c53b82d">&#9670;&#160;</a></span>setInitialConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Solver::setInitialConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPosition.html">Position</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a> &gt;&#160;</td>
          <td class="paramname"><em>possibilities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A multi-tile version of <a class="el" href="classSolver.html#a30173570fd36893e302f9313fe030937">setInitialConstraint(Position p, TileKey possibility)</a></p>
<p >If an empty initializer list is passed, nothing will occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the grid position for the initial constraint </td></tr>
    <tr><td class="paramname">possibilities</td><td>the tile keys which will be allowed in this grid position </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30173570fd36893e302f9313fe030937" name="a30173570fd36893e302f9313fe030937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30173570fd36893e302f9313fe030937">&#9670;&#160;</a></span>setInitialConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Solver::setInitialConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPosition.html">Position</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a>&#160;</td>
          <td class="paramname"><em>possibility</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A method to set an <em>initial constraint</em>. An initial constraint involves a grid position and a tile key. The grid square at the given position is preemptively collapsed to the given tile key, with the results being propagated, before the algorithm begins. This gives the user more say in the kinds of solutions that the algorithm will reach.</p>
<p >Liberal use of initial constraints may lead to frequent contradictions, so limiting their use is adviced.</p>
<p >Unlike the adjacency constraint API, succesive calls to this method with the same position but different tile keys does not add them all to the grid position. It is a setter, not an inserter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the grid position for the initial constraint </td></tr>
    <tr><td class="paramname">possibility</td><td>the sole tile key which will be allowed in this grid position </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34198a1963bea018d0d7096dd36e3653" name="a34198a1963bea018d0d7096dd36e3653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34198a1963bea018d0d7096dd36e3653">&#9670;&#160;</a></span>setSeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Solver::setSeed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the seed for the random number generator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>the seed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d7406c53eecaf19b82b312791d8fcb0" name="a7d7406c53eecaf19b82b312791d8fcb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d7406c53eecaf19b82b312791d8fcb0">&#9670;&#160;</a></span>solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classGrid.html">Grid</a>&lt; <a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a> &gt; &gt; Solver::solve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Runs the wave-function collapse algorithm, returning a solved 2-dimensional square <a class="el" href="classGrid.html">Grid</a> or throwing an exception if the algorithm fails. The grid returned is of dimensions NxN. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>The dimensions of the square grid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A solved grid </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>Indicates that the grid could not be solved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a889f4d7fb4caa5d53a5a54ef31592d13" name="a889f4d7fb4caa5d53a5a54ef31592d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889f4d7fb4caa5d53a5a54ef31592d13">&#9670;&#160;</a></span>solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Solver::solve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGrid.html">Grid</a>&lt; <a class="el" href="classSolver.html#a624d11307b449d2e13dee24ec5170eed">TileKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>grid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Runs the wave-function collapse algorithm, solving in-place a 2-dimensional square <a class="el" href="classGrid.html">Grid</a> or throwing an exception if the algorithm fails. The grid modified is of dimensions NxN. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>The dimensions of the square grid. </td></tr>
    <tr><td class="paramname">grid</td><td>A grid to solve </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>Indicates that the grid could not be solved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="Solver_8h_source.html">Solver.h</a></li>
<li>src/Solver.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
